<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>iOS 音频（二）</title>
    <url>/2021/10/22/iOS%20%E9%9F%B3%E9%A2%91(%E4%BA%8C)/</url>
    <content><![CDATA[<blockquote>
<p>接上一节的音频，本章主要将音频处理问题</p>
</blockquote>
<h2 id="音频基础知识"><a href="#音频基础知识" class="headerlink" title="音频基础知识"></a>音频基础知识</h2><p>目前常见的音频格可以大致分为两种：</p>
<ol>
<li>有损压缩，例如：<code>MP3</code>、<code>AAC</code>、<code>OGG</code>、<code>WMA</code></li>
<li>无损压缩，例如：<code>ALAC</code>、<code>APE</code>、<code>FLAC</code>、<code>WAV</code></li>
</ol>
<p>其中，对声音进行采样、量化过程被称为<code>脉冲编码调制</code>（Pulse Code Modulation），简称<code>PCM</code>。PCM数据是最原始的音频数据完全无损，但占用空间大，(<code>PCM</code>电脑上可以用<code>FFPlay</code> 设置采样率后播放)</p>
<span id="more"></span>  
<p><strong>关于音频计算</strong></p>
<ul>
<li>采样率：指<strong>每秒钟取得声音样本的次数</strong>。采样频率越高，声音的质量也就越好，声音的还原也就越真实，但同时它占的资源比较多。由于人耳的分辨率很有限，太高的频率并不能分辨出来。</li>
<li>采样位数：即<strong>采样值</strong>或取样值（声音的连续强度被数字表示后可以分为多少级，即将采样样本幅度量化）。它是用来衡量声音波动变化的一个参数，也可以说是声卡的分辨率。它的数值越大，分辨率也就越高，所发出声音的能力越强。<ul>
<li>8 bit -&gt; 记录 256（2^8）个数，振幅划分成 256 个等级 </li>
<li>16 bit -&gt; 记录65536(2^16) 个数，振幅划分成 65536 个等级 </li>
</ul>
</li>
<li>通道数：<strong>声音的通道的数目</strong>。常有单声道和立体声之分，单声道的声音只能使用一个喇叭发声（有的也处理成两个喇叭输出同一个声道的声音），立体声可以使两个喇叭都发声（一般左右声道有分工） ，更能感受到空间效果，当然还有更多的通道数。<ul>
<li>单声道 mono</li>
<li>双声道 stereo （左右）</li>
<li>2.1 </li>
<li>5.1</li>
<li>7.1</li>
</ul>
</li>
<li>每秒数据大小：采样率 * 采样通道 * 位深度 / 8</li>
</ul>
<p>以项目中为例：</p>
<blockquote>
<p>采样率 = 44100，采样通道 = 1，位深度 =16，采样间隔 = 20ms</p>
<p>一秒钟50帧 ，每帧大小为： 88200 / 50 = 1764 byte == 882 short</p>
</blockquote>
<h2 id="iOS上的PCM"><a href="#iOS上的PCM" class="headerlink" title="iOS上的PCM"></a>iOS上的PCM</h2><p>通常来说，第一时间肯定是想的是格式之间的转换。现在网上有很多<code>PCM</code> 转换到各种类型的方案。例如：</p>
<ul>
<li>PCM -&gt; wav <a href="https://www.jianshu.com/p/007fd82b0940">pcm 转 wav代码</a></li>
<li>pcm -&gt; mp3 <a href="https://lame.sourceforge.io/">LAME</a></li>
<li>。。。</li>
</ul>
<blockquote>
<p>但是，我几乎没有找到其他格式能直接转换为<code>PCM</code>的代码(有可能是没有找到），若是有这一块需求的同学，建议联系sdk去做处理<br>有一点值得提的是，在iOS上，通过<code>AVAudioRecorder</code>录制的音频格式默认为PCM，其初始化的方法为：</p>
</blockquote>
<!--more-->  

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (nullable instancetype)initWithURL:(NSURL *)url settings:(NSDictionary&lt;NSString *, id&gt; *)settings error:(NSError **)outError;</span><br></pre></td></tr></table></figure>

<p>在这其中，iOS7 中。默认的setting是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; AVFormatIDKey = kAudioFormatLinearPCM;  </span><br><span class="line">AVLinearPCMBitDepthKey = 16;</span><br><span class="line">AVLinearPCMIsBigEndianKey = 0;</span><br><span class="line">AVLinearPCMIsFloatKey = 0; </span><br><span class="line">AVLinearPCMIsNonInterleaved = 0;</span><br><span class="line">AVNumberOfChannelsKey = 2; </span><br><span class="line">AVSampleRateKey = 44100;&#125;</span><br></pre></td></tr></table></figure>

<p>其中，比较重要的几个参数：</p>
<ul>
<li>AVFormatIDKey： 音频格式的标识，具体的分类的种类见下面的代码</li>
<li>AVLinearPCMBitDepthKey: 位宽</li>
<li>AVNumberOfChannelsKey： 通道数</li>
<li>AVSampleRateKey： 采样率</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CF_ENUM(AudioFormatID)</span><br><span class="line">&#123;</span><br><span class="line">    kAudioFormatLinearPCM               = &#x27;lpcm&#x27;,</span><br><span class="line">    kAudioFormatAC3                     = &#x27;ac-3&#x27;,</span><br><span class="line">    kAudioFormat60958AC3                = &#x27;cac3&#x27;,</span><br><span class="line">    kAudioFormatAppleIMA4               = &#x27;ima4&#x27;,</span><br><span class="line">    kAudioFormatMPEG4AAC                = &#x27;aac &#x27;,</span><br><span class="line">    kAudioFormatMPEG4CELP               = &#x27;celp&#x27;,</span><br><span class="line">    kAudioFormatMPEG4HVXC               = &#x27;hvxc&#x27;,</span><br><span class="line">    kAudioFormatMPEG4TwinVQ             = &#x27;twvq&#x27;,</span><br><span class="line">    kAudioFormatMACE3                   = &#x27;MAC3&#x27;,</span><br><span class="line">    kAudioFormatMACE6                   = &#x27;MAC6&#x27;,</span><br><span class="line">    kAudioFormatULaw                    = &#x27;ulaw&#x27;,</span><br><span class="line">    kAudioFormatALaw                    = &#x27;alaw&#x27;,</span><br><span class="line">    kAudioFormatQDesign                 = &#x27;QDMC&#x27;,</span><br><span class="line">    kAudioFormatQDesign2                = &#x27;QDM2&#x27;,</span><br><span class="line">    kAudioFormatQUALCOMM                = &#x27;Qclp&#x27;,</span><br><span class="line">    kAudioFormatMPEGLayer1              = &#x27;.mp1&#x27;,</span><br><span class="line">    kAudioFormatMPEGLayer2              = &#x27;.mp2&#x27;,</span><br><span class="line">    kAudioFormatMPEGLayer3              = &#x27;.mp3&#x27;,</span><br><span class="line">    kAudioFormatTimeCode                = &#x27;time&#x27;,</span><br><span class="line">    kAudioFormatMIDIStream              = &#x27;midi&#x27;,</span><br><span class="line">    kAudioFormatParameterValueStream    = &#x27;apvs&#x27;,</span><br><span class="line">    kAudioFormatAppleLossless           = &#x27;alac&#x27;,</span><br><span class="line">    kAudioFormatMPEG4AAC_HE             = &#x27;aach&#x27;,</span><br><span class="line">    kAudioFormatMPEG4AAC_LD             = &#x27;aacl&#x27;,</span><br><span class="line">    kAudioFormatMPEG4AAC_ELD            = &#x27;aace&#x27;,</span><br><span class="line">    kAudioFormatMPEG4AAC_ELD_SBR        = &#x27;aacf&#x27;,</span><br><span class="line">    kAudioFormatMPEG4AAC_ELD_V2         = &#x27;aacg&#x27;,</span><br><span class="line">    kAudioFormatMPEG4AAC_HE_V2          = &#x27;aacp&#x27;,</span><br><span class="line">    kAudioFormatMPEG4AAC_Spatial        = &#x27;aacs&#x27;,</span><br><span class="line">    kAudioFormatMPEGD_USAC              = &#x27;usac&#x27;,</span><br><span class="line">    kAudioFormatAMR                     = &#x27;samr&#x27;,</span><br><span class="line">    kAudioFormatAMR_WB                  = &#x27;sawb&#x27;,</span><br><span class="line">    kAudioFormatAudible                 = &#x27;AUDB&#x27;,</span><br><span class="line">    kAudioFormatiLBC                    = &#x27;ilbc&#x27;,</span><br><span class="line">    kAudioFormatDVIIntelIMA             = 0x6D730011,</span><br><span class="line">    kAudioFormatMicrosoftGSM            = 0x6D730031,</span><br><span class="line">    kAudioFormatAES3                    = &#x27;aes3&#x27;,</span><br><span class="line">    kAudioFormatEnhancedAC3             = &#x27;ec-3&#x27;,</span><br><span class="line">    kAudioFormatFLAC                    = &#x27;flac&#x27;,</span><br><span class="line">    kAudioFormatOpus                    = &#x27;opus&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于<code>AVAudioRecorder</code>的使用方法具体就不贴了,网上一找一大堆，关于控制的话，<code>AVAudioRecorder</code>提供了一个<code>AVAudioRecorderDelegate</code> 作为回调，方便我们控制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* A protocol for delegates of AVAudioRecorder */</span><br><span class="line">API_AVAILABLE(macos(10.7), ios(3.0), watchos(4.0)) API_UNAVAILABLE(tvos)</span><br><span class="line">@protocol AVAudioRecorderDelegate &lt;NSObject&gt;</span><br><span class="line">@optional </span><br><span class="line"></span><br><span class="line">/* audioRecorderDidFinishRecording:successfully: is called when a recording has been finished or stopped. This method is NOT called if the recorder is stopped due to an interruption. */</span><br><span class="line">- (void)audioRecorderDidFinishRecording:(AVAudioRecorder *)recorder successfully:(BOOL)flag;</span><br><span class="line"></span><br><span class="line">/* if an error occurs while encoding it will be reported to the delegate. */</span><br><span class="line">- (void)audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)recorder error:(NSError * __nullable)error;</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_IPHONE</span><br><span class="line"></span><br><span class="line">/* AVAudioRecorder INTERRUPTION NOTIFICATIONS ARE DEPRECATED - Use AVAudioSession instead. */</span><br><span class="line"></span><br><span class="line">/* audioRecorderBeginInterruption: is called when the audio session has been interrupted while the recorder was recording. The recorded file will be closed. */</span><br><span class="line">- (void)audioRecorderBeginInterruption:(AVAudioRecorder *)recorder NS_DEPRECATED_IOS(2_2, 8_0);</span><br><span class="line"></span><br><span class="line">/* audioRecorderEndInterruption:withOptions: is called when the audio session interruption has ended and this recorder had been interrupted while recording. */</span><br><span class="line">/* Currently the only flag is AVAudioSessionInterruptionFlags_ShouldResume. */</span><br><span class="line">- (void)audioRecorderEndInterruption:(AVAudioRecorder *)recorder withOptions:(NSUInteger)flags NS_DEPRECATED_IOS(6_0, 8_0);</span><br><span class="line"></span><br><span class="line">- (void)audioRecorderEndInterruption:(AVAudioRecorder *)recorder withFlags:(NSUInteger)flags NS_DEPRECATED_IOS(4_0, 6_0);</span><br><span class="line"></span><br><span class="line">/* audioRecorderEndInterruption: is called when the preferred method, audioRecorderEndInterruption:withFlags:, is not implemented. */</span><br><span class="line">- (void)audioRecorderEndInterruption:(AVAudioRecorder *)recorder NS_DEPRECATED_IOS(2_2, 6_0);</span><br><span class="line"></span><br><span class="line">#endif // TARGET_OS_IPHONE</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>AVAudioRecorderDelegate总共有6个回调，在iOS6.0中废弃掉两个，然后在iOS8.0又废掉两个。在以前的版本中被抛弃的回调接口，主要也是控制播放器在播放的过程中收到中断</p>
<p>比如，收到中断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)audioRecorderBeginInterruption:(AVAudioRecorder *)recorder</span><br></pre></td></tr></table></figure>

<h2 id="音视频编辑"><a href="#音视频编辑" class="headerlink" title="音视频编辑"></a>音视频编辑</h2><p>在iOS 中，音频编辑离不开<code>AVMutableComposition</code>，<code>AVMutableComposition</code> 提供了接口来插入或者删除轨道，也可以调整这些轨道的顺序。一个 <code>composition</code> 可以简单的认为是一组轨道（tracks）的集合，这些轨道可以是来自不同媒体资源（asset）。</p>
<blockquote>
<p>前提知识：一个工程文件中有很多轨道，如音频轨道1，音频轨道2，音频轨道3，视频轨道1，视频轨道2等等，每个轨道里有许多素材，对于每个视频素材，它可以进行缩放、旋转等操作，素材库中的视频拖到轨道中会分为视频轨和音频轨两个轨道。<a href="https://www.jianshu.com/p/ee868d0ff7c4">参考</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVAsset：素材库里的素材； </span><br><span class="line">AVAssetTrack：素材的轨道； </span><br><span class="line">AVMutableComposition ：一个用来合成视频的工程文件； </span><br><span class="line">AVMutableCompositionTrack ：工程文件中的轨道，有音频轨、视频轨等，里面可以插入各种对应的素材； </span><br><span class="line">AVMutableVideoCompositionLayerInstruction：视频轨道中的一个视频，可以缩放、旋转等； </span><br><span class="line">AVMutableVideoCompositionInstruction：一个视频轨道，包含了这个轨道上的所有视频素材； </span><br><span class="line">AVMutableVideoComposition：管理所有视频轨道，可以决定最终视频的尺寸，裁剪需要在这里进行； </span><br><span class="line">AVAssetExportSession：配置渲染参数并渲染。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一般来说，类似一个简单的mp3文件，它就只会有音频轨道。而对于一个mp4文件，它会有音频轨道、视频轨道（也可能没有，在写代码时，尤其需要注意），其次，PCM格式的文件是不存在轨道这类信息的，所以如果想要将PCM添加到视频中，一种比较笨的方法是，将PCM 先转换为mp3格式，再通过得到的mp3文件提取出音频轨道。</p>
<p>以一个例子来具体解释，需求很简单，我想将一个视频的音频替换成一个pcm文件，并保存为，mov的格式：</p>
<p>首先：初始化AVMutableComposition</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVMutableComposition *composition = [AVMutableComposition composition];</span><br></pre></td></tr></table></figure>

<p>其次，我需要获取两个资源文件，并且提取音轨/视频轨，并插入到<code>composition</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVURLAsset *videoAsset = [AVURLAsset assetWithURL:[NSURL fileURLWithPath:videoPath]];</span><br><span class="line">AVURLAsset *mp3Asset = [AVURLAsset assetWithURL:mp3Path];</span><br><span class="line">// 音频轨道提取</span><br><span class="line">AVMutableCompositionTrack *compositionAudioTrack = [composition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line">        [compositionAudioTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, mp3Asset.duration) ofTrack:[[mp3Asset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0] atTime:kCMTimeZero error:nil];</span><br><span class="line">// 视频轨道提取</span><br><span class="line">AVMutableCompositionTrack *compositionVideoTrack = [composition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line">    [compositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset.duration) ofTrack:[[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0] atTime:kCMTimeZero error:nil];</span><br></pre></td></tr></table></figure>

<p>导出工程，使用<code>AVAssetExportSession</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVAssetExportSession* assetExport = [[AVAssetExportSession alloc]initWithAsset:composition presetName:AVAssetExportPresetPassthrough];</span><br><span class="line">   assetExport.outputFileType = AVFileTypeQuickTimeMovie;</span><br><span class="line">   assetExport.outputURL = exportUrl;</span><br><span class="line">   assetExport.shouldOptimizeForNetworkUse = YES;</span><br><span class="line">   [assetExport exportAsynchronouslyWithCompletionHandler:</span><br><span class="line">    ^(void ) &#123;</span><br><span class="line">       // 导出结果</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>注意，我当前导出的格式为<code>mov</code>, 可选择的格式可以去 <code>AVMediaFormat</code> 中 <code>AVFileType</code> 去查看。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章主要是对音频处理这块，有一个简单的补充，可能后续遇到问题，会继续补充。如果有不对的地方，也欢迎及时纠正我，谢谢～</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>音频</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 音频（一）</title>
    <url>/2021/10/13/iOS%20%E9%9F%B3%E9%A2%91(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="AVAudioSession"><a href="#AVAudioSession" class="headerlink" title="AVAudioSession"></a>AVAudioSession</h2><blockquote>
<p>做项目的时候，合拍需求需要同时播放音视频，同时需要录制用户的声音。在做的过程中发现，不去设置AVAudioSession，则使用蓝牙耳机时，视频播放的声音仍然会通过扬声器播放，以及一些意想不到的问题。</p>
</blockquote>
<p><code>AVAudioSession</code> 会自带一些默认的设置，以便在没有设置的情况下，能够应对一些简单的场景</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/ASPG_intro_2x.png" alt="图片来自官方"></p>
<p>简单来说，<code>AVAudioSession</code>的作用分为三点：</p>
<ol>
<li>协调多个App的音频播放</li>
<li>告诉系统如何使用音频：录音、播放、边录边播</li>
<li>设置输入输出设备</li>
</ol>
<span id="more"></span>  

<p>APP启动的时候会自动帮激活<code>AVAudioSession</code>，APP维护一个<code>AVAudioSession</code> 的单例</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"></span><br><span class="line"><span class="type">AVAudioSession</span>.sharedInstance()</span><br></pre></td></tr></table></figure>

<h3 id="AVAudioSession-Category"><a href="#AVAudioSession-Category" class="headerlink" title="AVAudioSession Category"></a>AVAudioSession Category</h3><p>目前<code>AVAudioSession</code> 所支持的<code>category</code> 共有 7 种：</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>是否会被静音<br>键或锁屏键静音</th>
<th>是否打断不支持混音<br>播放的应用</th>
<th>是否允许音频<br>输入/输出</th>
<th><div style="width: 150pt">解释</div></th>
</tr>
</thead>
<tbody><tr>
<td>AVAudioSessionCategoryAmbient</td>
<td>Yes</td>
<td>NO</td>
<td>只输出</td>
<td>只播放音频，不会被打断</td>
</tr>
<tr>
<td>AVAudioSessionCategoryAudioProcessing</td>
<td>NO</td>
<td>YES</td>
<td>无输入和输出</td>
<td>音频处理</td>
</tr>
<tr>
<td>AVAudioSessionCategoryMultiRoute</td>
<td>NO</td>
<td>YES</td>
<td>支持输入和输出</td>
<td>支持音频播放和录制（允许多条音频流的同步输入和输出)</td>
</tr>
<tr>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>NO</td>
<td>默认 YES，可重写开关置为 NO</td>
<td>支持输入和输出</td>
<td>支持音频播放和录制。</td>
</tr>
<tr>
<td>AVAudioSessionCategoryPlayback</td>
<td>NO</td>
<td>默认 YES，可重写开关置为 NO</td>
<td>只输出</td>
<td>只播放音频，一般音乐播放器都会选择这个</td>
</tr>
<tr>
<td>AVAudioSessionCategoryRecord</td>
<td>NO（锁屏时依然保持录制）</td>
<td>YES</td>
<td>只输入</td>
<td>只支持音频录制</td>
</tr>
<tr>
<td>AVAudioSessionCategorySoloAmbient(默认)</td>
<td>YES</td>
<td>YES</td>
<td>只输出</td>
<td>只播放音频，会被打断</td>
</tr>
</tbody></table>
<p><strong>第一个坑：</strong></p>
<p>如果<code>AVAudioSession</code> 处于<code>inactive</code> 的状态，那么<code>setCategory</code> 会在激活时才发送，不会立即生效，若处于<code>active</code>状态，则立即生效。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try?</span> <span class="type">AVAudioSession</span>.sharedInstance().setCategory(.playAndRecord)</span><br><span class="line"><span class="keyword">try?</span> <span class="type">AVAudioSession</span>.sharedInstance().setActive(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">/// 建议在init方法里面就激活一下</span></span><br></pre></td></tr></table></figure>

<p>若当前App激活了<code>AVAudioSession</code>，则其他App的<code>AVAudioSession</code> 会失效，若想让其他App重新也能被激活：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">AVAudioSession</span>.sharedInstance().setActive(<span class="literal">true</span>, options: .notifyOthersOnDeactivation)</span><br></pre></td></tr></table></figure>



<p><strong>小结：</strong></p>
<p>到此为止。很清楚的可以看到，常见的：</p>
<p>若需求是单纯的音频播放，例如播放器等选择：AVAudioSessionCategoryPlayback</p>
<p>若需求是需要录制，例如录音机，录制视频等选择：AVAudioSessionCategoryRecord</p>
<p>若需求是需要录制同时播放声音，例如短视频合拍等选择：AVAudioSessionCategoryPlayAndRecord</p>
<h3 id="AVAudioSession-Option"><a href="#AVAudioSession-Option" class="headerlink" title="AVAudioSession Option"></a>AVAudioSession Option</h3><table>
<thead>
<tr>
<th>Option</th>
<th>说明</th>
<th>兼容的 Category</th>
<th><div style="width: 150pt">解释</div></th>
</tr>
</thead>
<tbody><tr>
<td>AVAudioSessionCategoryOptionMixWithOthers</td>
<td>允许和其他音频 mix</td>
<td>AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryPlayback AVAudioSessionCategoryMultiRoute</td>
<td>例如：当前App播放的声音想与QQ音乐播放的声音并存</td>
</tr>
<tr>
<td>AVAudioSessionCategoryOptionDuckOthers</td>
<td>智能调低冲突音频音量</td>
<td>AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryPlayback AVAudioSessionCategoryMultiRoute</td>
<td>例如：导航时，语音播报并不会打断QQ音乐的声音，只是让其他App声音变小</td>
</tr>
<tr>
<td>AVAudioSessionCategoryOptionAllowBluetooth</td>
<td>允许蓝牙音频输入</td>
<td>AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayAndRecord</td>
<td>若要支持蓝牙耳机，这个是必备的</td>
</tr>
<tr>
<td>AVAudioSessionCategoryOptionDefaultToSpeaker</td>
<td>默认输出音频到扬声器</td>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>将音频输出到扬声器</td>
</tr>
</tbody></table>
<p>除此之外，在iOS9还提供了<code>AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers</code>最新的iOS10又新加了两个<code>AVAudioSessionCategoryOptionAllowBluetoothA2DP</code>    、<code>AVAudioSessionCategoryOptionAllowAirPlay</code>用来支持蓝牙A2DP耳机和AirPlay。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 通过这个方法设置option</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setCategory</span>(<span class="keyword">_</span> <span class="params">category</span>: <span class="type">AVAudioSession</span>.<span class="type">Category</span>, <span class="params">options</span>: <span class="type">AVAudioSession</span>.<span class="type">CategoryOptions</span> <span class="operator">=</span> [])</span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>

<p>第二个坑：</p>
<p>一般来说，所有的<code>Category</code>和<code>Option</code>都会遵循 <code>last in wins</code> 原则，即最后接入的音频设备作为输入或输出的主设备。同时用于播放音频的App都需要考虑到用户使用蓝牙耳机的情况，若不设置<code>AVAudioSessionCategoryOptionAllowBluetooth</code>,则可能出现虽然链接蓝牙耳机，但在<code>一边录制一边播放</code>的情况下，音频还是会从扬声器中播放出来。</p>
<h3 id="AVAudioSession-Mode"><a href="#AVAudioSession-Mode" class="headerlink" title="AVAudioSession Mode"></a>AVAudioSession Mode</h3><p>以上的<code>Category</code>和<code>Option</code>基本上能够满足大部分的App使用，对于特定的情况，例如通话、游戏，<code>AVAudioSession</code>还有自己特殊的优化 <code>Mode</code>：</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>兼容的 Category</th>
<th><div style="width: 150pt">说明</div></th>
</tr>
</thead>
<tbody><tr>
<td>AVAudioSessionModeDefault</td>
<td>All</td>
<td>默认格式</td>
</tr>
<tr>
<td>AVAudioSessionModeVoiceChat</td>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>VoIP 类型的应用</td>
</tr>
<tr>
<td>AVAudioSessionModeGameChat</td>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>适用于游戏类应用</td>
</tr>
<tr>
<td>AVAudioSessionModeVideoRecording</td>
<td>AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord</td>
<td>适用于使用摄像头采集视频的应用，搭配AVCaptureSession使用</td>
</tr>
<tr>
<td>AVAudioSessionModeMoviePlayback</td>
<td>AVAudioSessionCategoryPlayback</td>
<td>适用于播放视频的应用</td>
</tr>
<tr>
<td>AVAudioSessionModeMeasurement</td>
<td>AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayback</td>
<td>最小化系统（？？？ 不是很清楚）</td>
</tr>
<tr>
<td>AVAudioSessionModeVideoChat</td>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td>视频聊天类型应用</td>
</tr>
<tr>
<td><strong>几个需要注意的地方</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>AVAudioSessionModeVoiceChat</code> 适用于VoIP（基于IP的语音传输英语：Voice over Internet Protocol，缩写为VoIP）这个模式下，会自动配置上<code>AVAudioSessionCategoryOptionAllowBluetooth</code> 和 <code>AVAudioSessionCategoryOptionDefaultToSpeaker</code>。系统将自动选择最佳的麦克风组合来支持视频聊天</li>
<li><code>AVAudioSessionModeVideoRecording</code> 适用于使用摄像头采集视频的应用, 与<code>AVCaptureSession</code> 结合来用可以更好地控制音视频的输入输出路径。(例如，设置 <code>automaticallyConfiguresApplicationAudioSession</code> 属性，系统会自动选择最佳输出路径.)</li>
</ul>
<h2 id="状态监听"><a href="#状态监听" class="headerlink" title="状态监听"></a>状态监听</h2><h3 id="耳机"><a href="#耳机" class="headerlink" title="耳机"></a>耳机</h3><p>这部分直接上代码吧：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 是否有耳机</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">isUseHeadphones</span>()</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> isUse <span class="operator">=</span> <span class="type">AVAudioSession</span>.sharedInstance().currentRoute.outputs.first &#123;</span><br><span class="line">            <span class="variable">$0</span>.portType.rawValue <span class="operator">==</span> <span class="type">AVAudioSession</span>.<span class="type">Port</span>.headphones.rawValue <span class="operator">||</span></span><br><span class="line">            <span class="variable">$0</span>.portType.rawValue <span class="operator">==</span> <span class="type">AVAudioSession</span>.<span class="type">Port</span>.bluetoothA2DP.rawValue <span class="operator">||</span></span><br><span class="line">            <span class="variable">$0</span>.portType.rawValue <span class="operator">==</span> <span class="type">AVAudioSession</span>.<span class="type">Port</span>.bluetoothHFP.rawValue <span class="operator">||</span></span><br><span class="line">            <span class="variable">$0</span>.portType.rawValue <span class="operator">==</span> <span class="type">AVAudioSession</span>.<span class="type">Port</span>.bluetoothLE.rawValue <span class="operator">||</span></span><br><span class="line">            <span class="variable">$0</span>.portType.rawValue <span class="operator">==</span> <span class="type">AVAudioSession</span>.<span class="type">Port</span>.airPlay.rawValue</span><br><span class="line">        &#125; <span class="operator">!=</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> isUse</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>判断耳机种类：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateHeadPhonesStatus</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> des <span class="operator">=</span> <span class="type">AVAudioSession</span>.sharedInstance().currentRoute.outputs.first <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> des.portType.rawValue <span class="operator">==</span> <span class="type">AVAudioSession</span>.<span class="type">Port</span>.headphones.rawValue &#123;</span><br><span class="line">            <span class="comment">// 有线耳机</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (des.portType.rawValue <span class="operator">==</span> <span class="type">AVAudioSession</span>.<span class="type">Port</span>.bluetoothA2DP.rawValue <span class="operator">||</span></span><br><span class="line">                    des.portType.rawValue <span class="operator">==</span> <span class="type">AVAudioSession</span>.<span class="type">Port</span>.bluetoothHFP.rawValue <span class="operator">||</span></span><br><span class="line">                    des.portType.rawValue <span class="operator">==</span> <span class="type">AVAudioSession</span>.<span class="type">Port</span>.bluetoothLE.rawValue <span class="operator">||</span></span><br><span class="line">                    des.portType.rawValue <span class="operator">==</span> <span class="type">AVAudioSession</span>.<span class="type">Port</span>.airPlay.rawValue) &#123;</span><br><span class="line">            <span class="comment">//  蓝牙耳机</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//外放扬声器</span></span><br><span class="line">        context<span class="operator">?</span>.controller<span class="operator">?</span>.handleChangeDeviceStatus(to: .loudSpeaker)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="外设状态"><a href="#外设状态" class="headerlink" title="外设状态"></a>外设状态</h3><p>首先需要注册一个<code>AVAudioSession.routeChangeNotification</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">observers.append(<span class="type">NotificationCenter</span>.default.addObserver(forName: <span class="type">AVAudioSession</span>.routeChangeNotification, object: <span class="literal">nil</span>, queue: .main) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] notification <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span><span class="operator">?</span>.handleSessionRouteChange(notification)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="type">UIApplication</span>.shared.beginReceivingRemoteControlEvents()</span><br></pre></td></tr></table></figure>

<p>目前状态是一个枚举，主要分为8种：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>AVAudioSessionRouteChangeReasonUnknown</td>
<td>未知原因</td>
</tr>
<tr>
<td>AVAudioSessionRouteChangeReasonNewDeviceAvailable</td>
<td>有新设备可用</td>
</tr>
<tr>
<td>AVAudioSessionRouteChangeReasonOldDeviceUnavailable</td>
<td>老设备不可用</td>
</tr>
<tr>
<td>AVAudioSessionRouteChangeReasonCategoryChange</td>
<td>类别改变了</td>
</tr>
<tr>
<td>AVAudioSessionRouteChangeReasonOverride</td>
<td>App重置了输出设置</td>
</tr>
<tr>
<td>AVAudioSessionRouteChangeReasonWakeFromSleep</td>
<td>从睡眠状态呼醒</td>
</tr>
<tr>
<td>AVAudioSessionRouteChangeReasonNoSuitableRouteForCategory</td>
<td>当前Category下没有合适的设备</td>
</tr>
<tr>
<td>AVAudioSessionRouteChangeReasonRouteConfigurationChange</td>
<td>Rotuer的配置改变了</td>
</tr>
</tbody></table>
<p>可以通过判断返回的枚举值，去做相应的处理，例如拔出耳机时，停止播放，更新耳机状体等等。</p>
<h2 id="其他的坑"><a href="#其他的坑" class="headerlink" title="其他的坑"></a>其他的坑</h2><h3 id="PlayAndRecord"><a href="#PlayAndRecord" class="headerlink" title="PlayAndRecord"></a>PlayAndRecord</h3><p>在一般情况下，当没有接入任何音频设备时，声音会通过<strong>扬声器</strong>来播放，但是一旦设置了<code>PlayAndRecord</code>,会将默认的输出设备转为<strong>听筒</strong>。</p>
<p>解决办法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种：通过overrideOutputAudioPort 方法设置</span></span><br><span class="line"><span class="type">AVAudioSession</span>.sharedInstance().overrideOutputAudioPort(<span class="type">AVAudioSession</span>.<span class="type">PortOverride</span>.speaker)</span><br><span class="line"><span class="comment">// 第二种：设置AVAudioSessionCategoryOptionDefaultToSpeaker</span></span><br><span class="line"><span class="type">AVAudioSession</span>.sharedInstance().setCategory(.playAndRecord, options: .defaultToSpeaker)</span><br></pre></td></tr></table></figure>
<p>第三种：<a href="https://developer.apple.com/documentation/mediaplayer/mpvolumeview">MPVolumeView</a> 让用户自己选择</p>
<h3 id="AirPods"><a href="#AirPods" class="headerlink" title="AirPods"></a>AirPods</h3><p>AirPods在不同系统上的表现<br>AirPods 系列耳机，对于系统的要求不一样，具体要求可以去<a href="https://support.apple.com/zh-cn/HT207974">官网</a>查看<br><img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/WX20211026-204244%402x.png" alt="图片来自苹果官网"><br>例如：<br>AirPods在iOS10.2以下表现和普通的蓝牙耳机类似，能手动通过蓝牙连接上手机。<br>AirPods在iOS10.2以上的能支持双击操作，双击播放音乐，双击停止音乐；分别对应远程线控中的<code>UIEventSubtypeRemoteControlPlay</code>、<code>UIEventSubtypeRemoteControlStop</code>等事件。</p>
<p>判断是否是AirPod</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAirPods</span>()</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> des <span class="operator">=</span> <span class="type">AVAudioSession</span>.sharedInstance().currentRoute.outputs</span><br><span class="line">        <span class="keyword">for</span> de <span class="keyword">in</span> des &#123;</span><br><span class="line">            <span class="keyword">if</span> de.portName.contains(<span class="string">&quot;AirPods&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>1. 远程控制的坑</strong></p>
<p>在使用AirPods 的情况下，<code>AVAudioSession</code> 的category 设置为<code>AVAudioSessionCategoryPlayback</code>，此时APP只用于播放音频，能够<strong>自动适配远程控制</strong>。<strong>但是</strong>如果是<code>AVAudioSessionCategoryPlayAndRecord</code>，此时APP既需要播放音频，也需要录制音频。<strong>不能自动适配远程控制</strong><br>解决办法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置option .alllowBluetooth  PS: 设备需要的系统不满足使用</span></span><br><span class="line"><span class="keyword">try?</span> <span class="type">AVAudioSession</span>.sharedInstance().setCategory(.playAndRecord, options: .allowBluetooth)</span><br><span class="line"><span class="comment">// 设置option .allowBluetoothA2DP  PS: 设备需要的系统满足使用 且 iOS10 以后才有这个选项</span></span><br><span class="line"><span class="keyword">try?</span> <span class="type">AVAudioSession</span>.sharedInstance().setCategory(.playAndRecord, options: .allowBluetoothA2DP)</span><br></pre></td></tr></table></figure>
<p><strong>2. 音频输出的问题</strong></p>
<p>对于一般情况：</p>
<ul>
<li><code>AVAudioSessionCategoryPlayAndRecord</code> + <code>AVAudioSessionModeDefault</code> + <code>AVAudioSessionCategoryOptionDefaultToSpeaker</code> 声音会通过扬声器播放出来</li>
<li><code>AVAudioSessionCategoryPlayAndRecord</code> + <code>AVAudioSessionModeDefault</code> 声音会通过听筒播放出来</li>
</ul>
<p><strong>但是</strong>在AirPod的情况下:</p>
<ul>
<li><p><code>AVAudioSessionCategoryPlayAndRecord</code> + <code>AVAudioSessionModeDefault</code> + <code>AVAudioSessionCategoryOptionAllowBluetoothA2DP</code> 能连接上，并能远程控制。</p>
</li>
<li><p><code>AVAudioSessionCategoryPlayAndRecord</code> + <code>AVAudioSessionModeDefault</code> + <code>AVAudioSessionCategoryOptionAllowBluetooth</code> 能连接上，但是不能远程控制。</p>
</li>
</ul>
<p>如果是设置的其它模式，比如设置了模式，坑坑坑坑</p>
<ul>
<li><code>AVAudioSessionCategoryPlayAndRecord</code> + <code>AVAudioSessionModeVoiceChat</code></li>
<li><code>AVAudioSessionCategoryPlayAndRecord</code> + <code>AVAudioSessionModeDefault</code> + <code>AVAudioSessionCategoryOptionDefaultToSpeaker</code></li>
</ul>
<p>不能连上Airpods了，并且在控制中心面板中也没有AirPods选项。</p>
<p><strong>3. 录制播放声音不清晰</strong></p>
<p>打Log发现，默认的<code>AVAudioSessionCategoryPlayback</code> 模式下，耳机使用的模式是<code>BluetoothA2DPOutput</code></p>
<p><strong>但是</strong> 在<code>AVAudioSessionCategoryPlayAndRecord</code> 模式下，耳机使用的是<code>BluetoothHFP</code></p>
<blockquote>
<ul>
<li>HeadsetPro-file（HSP）代表耳机功能，提供手机与耳机之间通信所需的基本功能。</li>
<li>HandProfile（HFP）则代表免提功能，HFP在HSP的基础上增加了某些扩展功能。</li>
<li>Advanced Audio Distribution Profile（A2DP），指的是蓝牙音频传输模型协定。</li>
</ul>
<p>HFP格式的蓝牙耳机支持手机功能比较完整，用户可在耳机上操作手机设定好的重拨、来电保留、来电拒听等免提选项功能。A2DP是高级音频传送规格，允许传输立体声音频信号，相比用于 HSP 和 HFP 的单声道加密，质量要好得多。<br><a href="https://www.jianshu.com/p/04a1dc879c13">https://www.jianshu.com/p/04a1dc879c13</a></p>
</blockquote>
<p>在Apple 官方描述中：</p>
<blockquote>
<p>“If an application uses the setPreferredInput:error: method to select a Bluetooth HFP input, the output will automatically be changed to the Bluetooth HFP output. <strong>Moreover, selecting a Bluetooth HFP output using the MPVolumeView’s route picker will automatically change the input to the Bluetooth HFP input. Therefore both the input and output will always end up on the Bluetooth HFP device even though only the input or output was set individually.</strong>“</p>
</blockquote>
<p>大众的解决方案：</p>
<ul>
<li><p>维持原状的方案，就是继续采用HFP来进行音频的输入和输出，这种方案可以保证输入音频由支架的麦克风来提供，输出继续由支架来进行转发。但是，问题就是会导致音乐播放的音质差.</p>
</li>
<li><p>采用A2DP来进行高质量的蓝牙音频输出，保证歌曲、声音的播放质量，采用手机麦克风来进行音频输入而不通过蓝牙来采集音频。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对于一些音频知识的总结，本篇主要是针对<code>AVAudioSession</code>做的分析，若有问题，请还望多包涵和指正。下一小节将会去介绍音频处理相关的内容。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>音频</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存</title>
    <url>/2021/10/28/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="虚拟内存的概念、特征以及虚拟内存的实现"><a href="#虚拟内存的概念、特征以及虚拟内存的实现" class="headerlink" title="虚拟内存的概念、特征以及虚拟内存的实现"></a>虚拟内存的概念、特征以及虚拟内存的实现</h1><h2 id="传统存储管理方式的特征"><a href="#传统存储管理方式的特征" class="headerlink" title="传统存储管理方式的特征"></a>传统存储管理方式的特征</h2><p>各种内存管理策略都是为了同时将多个进程保存在内存中以便允许多道程序设计。它们都具有以下两个共同的特征：</p>
<h4 id="1-一次性"><a href="#1-一次性" class="headerlink" title="1) 一次性"></a>1) 一次性</h4><p>作业必须一次性全部装入内存后，方能开始运行。这会导致两种情况发生：</p>
<ul>
<li>当作业很大，不能全部被装入内存时，将使该作业无法运行；</li>
<li>当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</li>
</ul>
<h4 id="2-驻留性"><a href="#2-驻留性" class="headerlink" title="2) 驻留性"></a>2) 驻留性</h4><p>作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程，会因等待I/O而被阻塞，可能处于长期等待状态。</p>
<p>由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</p>
<span id="more"></span>

<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>要真正理解虚拟内存技术的思想，首先必须了解计算机中著名的局部性原理。著名的 Bill Joy (SUN公司CEO)说过：”在研究所的时候，我经常开玩笑地说高速缓存是计算机科学中唯一重要的思想。事实上，髙速缓存技术确实极大地影响了计算机系统的设计。“快表、 页高速缓存以及虚拟内存技术从广义上讲，都是属于高速缓存技术。这个技术所依赖的原理就是局部性原理。局部性原理既适用于程序结构，也适用于数据结构（更远地讲，Dijkstra 著名的关于“goto语句有害”的论文也是出于对程序局部性原理的深刻认识和理解）。</p>
<p>局部性原理表现在以下两个方面：</p>
<ul>
<li>时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ul>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。  </p>
<h2 id="虚拟存储器的定义和特征"><a href="#虚拟存储器的定义和特征" class="headerlink" title="虚拟存储器的定义和特征"></a>虚拟存储器的定义和特征</h2><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</p>
<p>之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。虚拟存储器的大小由计算机的地址结构决定，并非是内存和外存的简单相加。虚拟存储器有以下三个主要特征：</p>
<ul>
<li>多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。</li>
<li>对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。</li>
<li>虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远大于实际的内存容量。</li>
</ul>
<h2 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a>虚拟内存技术的实现</h2><p>虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：</p>
<ul>
<li>请求分页存储管理。</li>
<li>请求分段存储管理。</li>
<li>请求段页式存储管理。</li>
</ul>
<p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：</p>
<ul>
<li>一定容量的内存和外存。</li>
<li>页表机制（或段表机制），作为主要的数据结构。</li>
<li>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。</li>
<li>地址变换机构，逻辑地址到物理地址的变换。</li>
</ul>
<h1 id="请求分页管理方式实现虚拟内存"><a href="#请求分页管理方式实现虚拟内存" class="headerlink" title="请求分页管理方式实现虚拟内存"></a>请求分页管理方式实现虚拟内存</h1><p>请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。</p>
<p>在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。</p>
<p>为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址变换机构。</p>
<h2 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h2><p>请求分页系统的页表机制不同于基本分页系统，请求分页系统在一个作业运行之前不要求全部一次性调入内存，因此在作业的运行过程中，必然会出现要访问的页面不在内存的情况，如何发现和处理这种情况是请求分页系统必须解决的两个基本问题。为此，在请求页表项中增加了四个字段，如图3-24所示。</p>
<p><img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/1-140F10202531Y.png" alt="请求分页系统中的页表项"></p>
<p>增加的四个字段说明如下：</p>
<ul>
<li>状态位P：用于指示该页是否已调入内存，供程序访问时参考。</li>
<li>访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近己有多长时间未被访问，供置换算法换出页面时参考。</li>
<li>修改位M：标识该页在调入内存后是否被修改过。</li>
<li>外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li>
</ul>
<h2 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h2><p>在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成唤醒)，如果内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存)。</p>
<p>缺页中断作为中断同样要经历，诸如保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等几个步骤。但与一般的中断相比，它有以下两个明显的区别：</p>
<ul>
<li>在指令执行期间产生和处理中断信号，而非一条指令执行完后，属于内部中断。</li>
<li>一条指令在执行期间，可能产生多次缺页中断。</li>
</ul>
<h2 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h2><p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的。</p>
<p><img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/1-140F102004L08.jpg" alt="请求分页中的地址变换过程"></p>
<p>如图所示，在进行地址变换时，先检索快表：</p>
<ul>
<li>若找到要访问的页，便修改页表项中的访问位（写指令则还须重置修改位)，然后利用页表项中给出的物理块号和页内地址形成物理地址。</li>
<li>若未找到该页的页表项，应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已调入内存，未调入则产生缺页中断，请求从外存把该页调入内存。</li>
</ul>
<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p>进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区。</p>
<p>选择调出页面的算法就称为页面置换算法。好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。</p>
<p>常见的置换算法有以下四种。</p>
<h2 id="1-最佳置换算法-OPT"><a href="#1-最佳置换算法-OPT" class="headerlink" title="1. 最佳置换算法(OPT)"></a>1. 最佳置换算法(OPT)</h2><p>最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。</p>
<p>最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串：<br>  7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</p>
<p>进程运行时，先将7, 0, 1三个页面依次装入内存。进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。然后，访问页面0时，因为已在内存中所以不必产生缺页中断。访问页面3时又会根据最佳置换算法将页面1淘汰……依此类推，如图3-26所示。从图中可以看出釆用最佳置换算法时的情况。</p>
<p>可以看到，发生缺页中断的次数为9，页面置换的次数为6。</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>3</td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺页否</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>图3-26  利用最佳置换算法时的置换图</p>
<h2 id="2-先进先出-FIFO-页面置换算法"><a href="#2-先进先出-FIFO-页面置换算法" class="headerlink" title="2. 先进先出(FIFO)页面置换算法"></a>2. 先进先出(FIFO)页面置换算法</h2><p>优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>图3-27  利用FIFO置换算法时的置换图</p>
<p>这里仍用上面的实例，釆用FIFO算法进行页面置换。进程访问页面2时，把最早进入内存的页面7换出。然后访问页面3时，再把2, 0, 1中最先进入内存的页换出。由图 3-27可以看出，利用FIFO算法时进行了 12次页面置换，比最佳置换算法正好多一倍。</p>
<p>FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为Belady异常，如图3-28所示。只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>物理块1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td></td>
<td></td>
<td>,5’</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>物理块2</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>物理块3</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>物理块2*</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>物理块3*</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>物理块4*</td>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>图 3-28  Belady 异常</p>
<h2 id="3-最近最久未使用-LRU-置换算法"><a href="#3-最近最久未使用-LRU-置换算法" class="headerlink" title="3. 最近最久未使用(LRU)置换算法"></a>3. 最近最久未使用(LRU)置换算法</h2><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p>
<p>再对上面的实例釆用LRU算法进行页面置换，如图3-29所示。进程第一次对页面2访问时，将最近最久未被访问的页面7置换出去。然后访问页面3时，将最近最久未使用的页面1换出。</p>
<table>
<thead>
<tr>
<th>访问页面</th>
<th>7</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>3</th>
<th>0</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>0</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>2</th>
<th>0</th>
<th>1</th>
<th>7</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>物理块1</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理块2</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理块3</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td>3</td>
<td></td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺页否</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>图3-29  LRU页面置换算法时的置换图</p>
<p>在图3-29中，前5次置换的情况与最佳置换算法相同，但两种算法并无必然联系。实际上，LRU算法根据各页以前的情况，是“向前看”的，而最佳置换算法则根据各页以后的使用情况，是“向后看”的。</p>
<p>LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。</p>
<h2 id="4-时钟-CLOCK-置换算法"><a href="#4-时钟-CLOCK-置换算法" class="headerlink" title="4. 时钟(CLOCK)置换算法"></a>4. 时钟(CLOCK)置换算法</h2><p>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。</p>
<p>简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。</p>
<p>CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：</p>
<ol>
<li>最近未被访问，也未被修改(u=0, m=0)。</li>
<li>最近被访问，但未被修改(u=1, m=0)。</li>
<li>最近未被访问，但被修改(u=0, m=1)。</li>
<li>最近被访问，被修改(u=1, m=1)。</li>
</ol>
<p>算法执行如下操作步骤：</p>
<ol>
<li>从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。</li>
<li>如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。</li>
<li>如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。</li>
</ol>
<p>改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。</p>
<h1 id="页面分配策略：驻留集大小、调入页面的时机以及从何处调入页面"><a href="#页面分配策略：驻留集大小、调入页面的时机以及从何处调入页面" class="headerlink" title="页面分配策略：驻留集大小、调入页面的时机以及从何处调入页面"></a>页面分配策略：驻留集大小、调入页面的时机以及从何处调入页面</h1><h2 id="驻留集大小"><a href="#驻留集大小" class="headerlink" title="驻留集大小"></a>驻留集大小</h2><p>对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页。也就是说，给特定的进程分配多大的主存空间，这需要考虑以下几点：</p>
<ol>
<li>分配给一个进程的存储量越小，在任何时候驻留在主存中的进程数就越多，从而可以提高处理机的时间利用效率。</li>
<li>如果一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高。</li>
<li>如桌页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</li>
</ol>
<p>基于这些因素，现代操作系统通常釆用三种策略：</p>
<ol>
<li>固定分配局部置换。它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。</li>
<li>可变分配全局置换。这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。</li>
<li>可变分配局部置换。它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度； 反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li>
</ol>
<h2 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h2><p>为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略：</p>
<ol>
<li>预调页策略。根据局部性原理，一次调入若干个相邻的页可能会比一次调入一页更高效。但如果调入的一批页面中大多数都未被访问，则又是低效的。所以就需要釆用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。故这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。</li>
<li>请求调页策略。进程在运行中需要访问的页面不在内存而提出请求，由系统将所需页面调入内存。由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略。它的缺点在于每次只调入一页，调入调出页面数多时会花费过多的I/O开销。</li>
</ol>
<h2 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h2><p>请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是釆用连续分配方式，而文件区釆用离散分配方式，故对换区的磁盘I/O速度比文件区的更快。这样从何处调入页面有三种情况：</p>
<ol>
<li>系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</li>
<li>系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。</li>
<li>UNIX方式：与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。</li>
</ol>
<h1 id="页面抖动-颠簸-和工作集-驻留集"><a href="#页面抖动-颠簸-和工作集-驻留集" class="headerlink" title="页面抖动(颠簸)和工作集(驻留集)"></a>页面抖动(颠簸)和工作集(驻留集)</h1><h2 id="页面抖动（颠簸）"><a href="#页面抖动（颠簸）" class="headerlink" title="页面抖动（颠簸）"></a>页面抖动（颠簸）</h2><p>在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p>
<p>频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。</p>
<h2 id="工作集（驻留集）"><a href="#工作集（驻留集）" class="headerlink" title="工作集（驻留集）"></a>工作集（驻留集）</h2><p>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p>
<p>工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p>
<p>正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统中调度算法（FCFS、RR、SPN、SRT、HRRN）</title>
    <url>/2021/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88FCFS%E3%80%81RR%E3%80%81SPN%E3%80%81SRT%E3%80%81HRRN%EF%BC%89/</url>
    <content><![CDATA[<h2 id="决策模式"><a href="#决策模式" class="headerlink" title="决策模式"></a>决策模式</h2><p>决策模式说明选择函数在执行的瞬间的处理方式，通常分为以下两类：</p>
<ul>
<li><p>非抢占：一旦进入运行状态，就不会终止直到运行结束。</p>
</li>
<li><p>抢占：当前正在运行的进程可以被打断，并转移到就绪态。</p>
</li>
</ul>
<p> 一个调度算法是否能抢占，对进程的顺序有着极大的影响。</p>
 <span id="more"></span>

<h2 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h2><p> 先来先服务是最简单的策略，也成为先进先出FIFO。首先它是一个非抢占的。如字面的意思，它根据进程到达时间决定先运行哪一个进程。</p>
<p> 这里给出一个实际的例子。以表格的形式表现出在FIFO策略下各进程的情况。</p>
<p><img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/20180121005045274" alt="img"></p>
<p>简单说就是依次执行完成，从时间轴上来看</p>
<p><img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/20180121005129300" alt="img"></p>
<h2 id="最短进程优先SPN"><a href="#最短进程优先SPN" class="headerlink" title="最短进程优先SPN"></a>最短进程优先SPN</h2><p>也称最短作业优先（Short Job First,SJF）。它也是一个非抢占的。是根据服务的时间经行选择。在这里要注意下到达时间的顺序。比如实例中单纯以大小来排序的话是E-A-C-D-B,但正确的排序一定是A-B为开头。以时间为顺序：</p>
<p><img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/20180121005249291" alt="img"></p>
<p>例子中A运行结束时间为3，这时只有B进程等待。所以A运行结束后直接运行B。B结束后时间点到9，CDE都在等待。这个时候就选择服务时间最少的E，然后是较少的C，最后是D。以表格的形式展示：</p>
<p><img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/20180121005319025" alt="img"></p>
<h2 id="最短剩余时间优先SRT"><a href="#最短剩余时间优先SRT" class="headerlink" title="最短剩余时间优先SRT"></a>最短剩余时间优先SRT</h2><p>SRT是针对SPN增加了抢占机制的版本，就好比例子中B运行时间非常长，在这期间其他所有的进程都在等待，如果将其中断，先处理所需时间少的，运行效率会有显著提升。一定要先明确SRT是抢占的。先给出时间为顺序的图：</p>
<p><img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/20180121005401910" alt="img"></p>
<ol>
<li><p>A先运行至2，B到达等待。</p>
</li>
<li><p>A运行到3结束，B开始运行。</p>
</li>
<li><p>B开始运行，运行到4时，C进程到达，且C只需要4，此时B还需要5。所以先运行C，B继续等待。</p>
</li>
<li><p>C运行时间点到达6时，D到达，D需要5，进入等待，排在B后。</p>
</li>
<li><p>C运行结束，此时时间点是8，E到达，运行时间只要2，小于等待的BD，直接运行。</p>
</li>
<li><p>C运行结束，B开始运行。</p>
</li>
<li><p>B运行结束，D开始运行。</p>
</li>
</ol>
<p>以表格的形式展现：</p>
<p><img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/20180121005423134" alt="img"></p>
<h2 id="轮转RR"><a href="#轮转RR" class="headerlink" title="轮转RR"></a>轮转RR</h2><p>轮转也称时间片技术（time slicing，SL），对于轮转法，最重要的是时间片的长度。轮转算法以一个周期（q）产生中断，当中断发生时，当前运行的程序置于就绪队列（队尾）中，然后基于FCFS选择下一个就绪作业运行。在这里我们以时间片q=1举例。</p>
<p>q=1，所以一次只能运行一个时间片。</p>
<p>0：A1运转（右标表示运行了几个）</p>
<p>1：A2运转</p>
<p>2：B1运转，A3等待（B开始）</p>
<p>3：A3运转，B2等待</p>
<p>4：B2运转，C1等待，（A结束）</p>
<p>5：C1运转，B3等待（C开始）</p>
<p>6：B3运转，D1等待，C2等待</p>
<p>7：D1运转，C2等待，B4等待（D开始）</p>
<p>8：C2运行，B4等待，E1等待，D2等待</p>
<p>9：B4运行，E1等待，D2等待，C3等待</p>
<p>10：E1运行，D2等待，C3等待，B5等待（E开始）</p>
<p>11：D2运行，C3等待，B5等待，E2等待</p>
<p>12：C3运行，B5等待，E2等待，D3等待</p>
<p>13：B5运行，E2等待，D3等待，C4等待</p>
<p>14：E2运行，D3等待，C4等待，B6等待</p>
<p>15：D3运行，C4等待，B6等待（E结束）</p>
<p>16：C4运行，B6等待，D4等待</p>
<p>17：B6运行，D4等待（C结束）</p>
<p>18：D5运行，D6等待（B结束）</p>
<p>19：D6运行</p>
<p>20：D结束</p>
<p>表格展示：</p>
<p> <img src="https://imagedatabase-1259343097.cos.ap-beijing.myqcloud.com/blogImage/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/20180121005505612" alt="img"></p>
<h2 id="高响应比优先HRRN"><a href="#高响应比优先HRRN" class="headerlink" title="高响应比优先HRRN"></a>高响应比优先HRRN</h2><p>高响应比优先调度算法</p>
<p>高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。 </p>
<p>响应比的变化规律可描述为：</p>
<p>响应比=（等待时间+服务时间）/服务时间</p>
<p>根据公式可知：</p>
<p>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。</p>
<p>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</p>
<p>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
